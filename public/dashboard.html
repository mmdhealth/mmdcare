<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMDCare Platform - Care Provider Dashboard</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="dashboard">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <img src="Assets/mmdconnect.png" alt="MMDCare" class="logo">
                <span class="logo-text">MMDCare</span>
            </div>
            
            <nav class="sidebar-nav">
                <ul class="nav-list">
                    <li class="nav-item active">
                        <img src="Assets/översikt.png" alt="Översikt" class="nav-icon">
                        <span class="nav-text">Översikt</span>
                    </li>
                    <li class="nav-item journaldata">
                        <img src="Assets/journaldata.png" alt="Journaldata" class="nav-icon">
                        <span class="nav-text">Journaldata</span>
                    </li>
                    <li class="nav-item">
                        <a href="gpt-chat.html" class="nav-link">
                            <img src="Assets/halsa-gpt.png" alt="Hälsa+ GPT" class="nav-icon">
                            <span class="nav-text">Hälsa+ GPT</span>
                        </a>
                    </li>
                </ul>
                
                <ul class="nav-list-bottom">
                    <li class="nav-item">
                        <img src="Assets/hjälp.png" alt="Hjälp" class="nav-icon">
                        <span class="nav-text">Hjälp</span>
                    </li>
                    <li class="nav-item">
                        <img src="Assets/inställningar.png" alt="Inställningar" class="nav-icon">
                        <span class="nav-text">Inställningar</span>
                    </li>
                    <li class="nav-item" onclick="showLogoutOverlay()">
                        <img src="Assets/avsluta.png" alt="Avsluta" class="nav-icon">
                        <span class="nav-text">Avsluta</span>
                    </li>
                </ul>
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <div class="content-header">
                <div class="patient-info">
                    <h1 id="patient-name-header">Patient: <span data-patient-name="full">Anders Boman</span></h1>
                    <p class="patient-date">2024-09-09</p>
                </div>
                <div class="user-info">
                    <div class="user-meta">
                    <span class="user-name" data-doctor-name-source data-doctor-name="full">Dr. Anna Andersson</span>
                        <p class="user-title">Kardiologist</p>
                    </div>
                    <div class="user-avatar">AA</div>
                </div>
            </div>

            <section class="mini-insights card-animate">
                <h2 class="card-title">Snabbstatus</h2>
                <div class="mini-insights-grid">
                    <article class="mini-card" data-metric-card="bloodPressure">
                        <h3>Blodtryck</h3>
                        <span class="mini-value">–</span>
                    </article>
                    <article class="mini-card" data-metric-card="heartRate">
                        <h3>Hjärtfrekvens</h3>
                        <span class="mini-value">–</span>
                    </article>
                    <article class="mini-card" data-metric-card="oxygen">
                        <h3>Syresättning</h3>
                        <span class="mini-value">–</span>
                    </article>
                    <article class="mini-card" data-metric-card="weight">
                        <h3>Vikt &amp; vätska</h3>
                        <span class="mini-value">–</span>
                    </article>
                    <article class="mini-card" data-metric-card="steps">
                        <h3>Steg</h3>
                        <span class="mini-value">–</span>
                    </article>
                        </div>
            </section>

            <section class="metrics-tabs card-animate">
                <h2 class="card-title metrics-title">Mätvärden</h2>
                <div class="metrics-tabs-header">
                    <button class="metrics-tab active" data-tab="hemodynamik">Hemodynamik</button>
                    <button class="metrics-tab" data-tab="hf-vatska">HF &amp; vätska</button>
                    <button class="metrics-tab" data-tab="risk-lab">Risk &amp; lab</button>
                    </div>
                <div class="metrics-tab-panels">
                    <div class="tab-panel active" data-tab-panel="hemodynamik">
                        <div class="graph-card-grid">
                            <div class="graph-card" data-chart-key="bloodPressure">
                                <div class="graph-card-header">
                                    <h3>Blodtryck över tid</h3>
                                    <span class="graph-value" data-graph-value="bloodPressure">Värde saknas</span>
                                </div>
                                <div class="graph-placeholder">
                                    <span class="axis y"></span>
                                    <span class="axis x"></span>
                                    <canvas id="chart-bloodPressure"></canvas>
                                </div>
                            </div>
                            <div class="graph-card" data-chart-key="heartRate">
                                <div class="graph-card-header">
                                    <h3>Hjärtfrekvens &amp; AF-börda</h3>
                                    <span class="graph-value" data-graph-value="heartRate">Värde saknas</span>
                                </div>
                                <div class="graph-placeholder">
                                    <span class="axis y"></span>
                                    <span class="axis x"></span>
                                    <canvas id="chart-heartRate"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="tab-panel" data-tab-panel="hf-vatska">
                        <div class="graph-card-grid">
                            <div class="graph-card" data-chart-key="weight">
                                <div class="graph-card-header">
                                    <h3>Vikt &amp; diuretika</h3>
                                    <span class="graph-value" data-graph-value="weight">Värde saknas</span>
                                </div>
                                <div class="graph-placeholder">
                                    <span class="axis y"></span>
                                    <span class="axis x"></span>
                                    <canvas id="chart-weight"></canvas>
                                </div>
                            </div>
                            <div class="graph-card" data-chart-key="ntprobnp">
                                <div class="graph-card-header">
                                    <h3>NT-proBNP</h3>
                                    <span class="graph-value" data-graph-value="ntprobnp">Värde saknas</span>
                                </div>
                                <div class="graph-placeholder">
                                    <span class="axis y"></span>
                                    <span class="axis x"></span>
                                    <canvas id="chart-ntprobnp"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="tab-panel" data-tab-panel="risk-lab">
                        <div class="graph-card-grid">
                            <div class="graph-card" data-chart-key="ldl">
                                <div class="graph-card-header">
                                    <h3>LDL över tid</h3>
                                    <span class="graph-value" data-graph-value="ldl">Värde saknas</span>
                                </div>
                                <div class="graph-placeholder">
                                    <span class="axis y"></span>
                                    <span class="axis x"></span>
                                    <canvas id="chart-ldl"></canvas>
                                </div>
                            </div>
                            <div class="graph-card" data-chart-key="glucose">
                                <div class="graph-card-header">
                                    <h3>HbA1c över tid</h3>
                                    <span class="graph-value" data-graph-value="glucose">Värde saknas</span>
                                </div>
                                <div class="graph-placeholder">
                                    <span class="axis y"></span>
                                    <span class="axis x"></span>
                                    <canvas id="chart-glucose"></canvas>
                                </div>
                            </div>
                            <div class="graph-card" data-chart-key="egfr">
                                <div class="graph-card-header">
                                    <h3>eGFR över tid</h3>
                                    <span class="graph-value" data-graph-value="egfr">Värde saknas</span>
                                </div>
                                <div class="graph-placeholder">
                                    <span class="axis y"></span>
                                    <span class="axis x"></span>
                                    <canvas id="chart-egfr"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <div class="knowledge-journal-layout">
                <section class="knowledge-grid-card card-animate">
                    <h2 class="card-title">Patientdata</h2>
                    <div class="knowledge-grid">
                        <a href="heart.html" class="organ-item-link">
                            <div class="organ-item provsvar-card">
                                <div class="provsvar-main">
                                    <h3 class="organ-name">Data</h3>
                                    <div class="provsvar-status">
                                        <span id="provsvarStatusIndicator" class="status-indicator neutral"></span>
                                        <span id="provsvarDataState" class="data-count">Ingen data tillgänglig</span>
                                    </div>
                                </div>
                                <div class="chevron">›</div>
                            </div>
                        </a>
                        <a href="#" class="organ-item-link">
                            <div class="organ-item provsvar-card">
                                <div class="provsvar-main">
                                    <h3 class="organ-name">Journalanteckningar</h3>
                                    <div class="provsvar-status">
                                        <span class="status-indicator neutral"></span>
                                        <span class="data-count">Ingen data tillgänglig</span>
                                    </div>
                                </div>
                                <div class="chevron">›</div>
                            </div>
                        </a>
                        <a href="#" class="organ-item-link">
                            <div class="organ-item provsvar-card">
                                <div class="provsvar-main">
                                    <h3 class="organ-name">Diagnoser</h3>
                                    <div class="provsvar-status">
                                        <span class="status-indicator neutral"></span>
                                        <span class="data-count">Ingen data tillgänglig</span>
                                    </div>
                                </div>
                                <div class="chevron">›</div>
                            </div>
                        </a>
                        <a href="#" class="organ-item-link">
                            <div class="organ-item provsvar-card">
                                <div class="provsvar-main">
                                    <h3 class="organ-name">Läkemedel</h3>
                                    <div class="provsvar-status">
                                        <span class="status-indicator neutral"></span>
                                        <span class="data-count">Ingen data tillgänglig</span>
                                    </div>
                                </div>
                                <div class="chevron">›</div>
                            </div>
                        </a>
                        <a href="#" class="organ-item-link">
                            <div class="organ-item provsvar-card">
                                <div class="provsvar-main">
                                    <h3 class="organ-name">Larm</h3>
                                    <div class="provsvar-status">
                                        <span class="status-indicator neutral"></span>
                                        <span class="data-count">Ingen data tillgänglig</span>
                                    </div>
                                </div>
                                <div class="chevron">›</div>
                            </div>
                        </a>
                        <a href="#" class="organ-item-link">
                            <div class="organ-item provsvar-card">
                                <div class="provsvar-main">
                                    <h3 class="organ-name">Symtom</h3>
                                    <div class="provsvar-status">
                                        <span class="status-indicator neutral"></span>
                                        <span class="data-count">Ingen data tillgänglig</span>
                                    </div>
                                </div>
                                <div class="chevron">›</div>
                            </div>
                        </a>
                        </div>
                </section>

                <div class="journal-provsvar-column">
                    <div class="file-count-card card-animate">
                        <h2 class="card-title">Uppladdade filer</h2>
                        <div class="file-count-content">
                            <div class="file-count-item">
                                <h3 class="file-count-label">Antal filer</h3>
                                <span id="fileCountValue" class="file-count-value">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Logout Overlay -->
    <div id="logout-overlay" class="logout-overlay" style="display: none;">
        <div class="logout-modal">
            <div class="logout-modal-content">
                <div class="logout-info-card">
                    <h3 style="margin: 0 0 8px 0; color: #1D212B; font-size: 20px;">Avsluta session</h3>
                    <p style="margin: 0; color: #666; font-size: 16px;">Är du säker på att du vill avsluta sessionen?</p>
                </div>
            </div>
            <div class="logout-modal-actions">
                <button onclick="hideLogoutOverlay()" class="logout-btn-cancel">Avbryt</button>
                <button onclick="confirmLogout()" class="logout-btn-confirm">Avsluta session</button>
            </div>
        </div>
    </div>
    <div id="importOverlay" class="import-overlay" aria-hidden="true">
        <div class="import-overlay-card">
            <div class="import-overlay-icon" id="importOverlayIcon">⬆︎</div>
            <h3 id="importOverlayTitle" class="import-overlay-title">Importerar patientdata</h3>
            <p id="importOverlayCopy" class="import-overlay-copy">Detta tar vanligtvis mindre än 30 sekunder.</p>
            <div id="importProgressTrack" class="import-progress-track">
                <div id="importProgressBar" class="import-progress-bar"></div>
            </div>
            <p id="importProgressText" class="import-progress-text">Förbereder import...</p>
        </div>
    </div>

    <script src="script.js?v=20250105"></script>
    <script>
        let uploadedFiles = [];
        let currentTransferId = null;
        let eventSource = null;
        let lastServerFileCount = 0;
        let currentSessionId = null;
        let filePollIntervalId = null;
        const notifiedFiles = new Set(); // Track files that have been notified
        
        // Clear notification tracking on page load (only track within current session)
        window.addEventListener('beforeunload', () => {
            notifiedFiles.clear();
        });
        const importOverlayState = {
            timerId: null,
            visible: false,
            totalSteps: 0,
            mode: null
        };
        const dashboardCharts = {};
        const metricCardElements = {};
        const graphValueElements = {};
        const excelAnalyticsState = {
            combinedMetrics: null,
            files: []
        };
        const chartCanvasIdMap = {
            bloodPressure: 'chart-bloodPressure',
            heartRate: 'chart-heartRate',
            weight: 'chart-weight',
            oxygen: 'chart-ntprobnp',
            ldl: 'chart-ldl',
            glucose: 'chart-glucose',
            egfr: 'chart-egfr'
        };
        const DASHBOARD_WAITING_OVERLAY_KEY = 'mmd_dashboard_waiting_overlay_seen';

        function hasSeenWaitingOverlay() {
            try {
                return localStorage.getItem(DASHBOARD_WAITING_OVERLAY_KEY) === 'true';
            } catch (error) {
                return false;
            }
        }

        function markWaitingOverlaySeen() {
            try {
                localStorage.setItem(DASHBOARD_WAITING_OVERLAY_KEY, 'true');
            } catch (error) {
                // Ignore storage errors (e.g. Safari private mode)
            }
        }

        function logout() {
            showLogoutOverlay();
        }

        // Trigger dashboard page animations
        document.addEventListener('DOMContentLoaded', async function() {
            // Clear notification tracking on page load
            notifiedFiles.clear();
            
            // CRITICAL: Store session start time ONLY if this is a new session (not a redirect from upload)
            // If we're being redirected from index.html after upload, sessionStartTime should already exist
            // If it doesn't exist, this is a new session after logout - set it now
            if (!localStorage.getItem('sessionStartTime')) {
                localStorage.removeItem('uploadNotificationShownForSession');
                const sessionStartTime = Date.now();
                localStorage.setItem('sessionStartTime', sessionStartTime.toString());
                console.log('New session started after logout, timestamp:', sessionStartTime);
            } else {
                console.log('Existing session, timestamp:', localStorage.getItem('sessionStartTime'));
            }
            currentSessionId = localStorage.getItem('sessionStartTime');
            
            // Update patient name immediately on page load
            const savedPatientName = localStorage.getItem('currentPatientName');
            if (savedPatientName) {
                const patientNameHeader = document.getElementById('patient-name-header');
                if (patientNameHeader) {
                    patientNameHeader.textContent = `Patient: ${savedPatientName}`;
                }
            }
            
            // Animate cards with staggered timing
            const cards = document.querySelectorAll('.card-animate');
            cards.forEach((card, index) => {
                setTimeout(() => {
                    card.classList.add('loaded');
                }, 100 + (index * 100));
            });
            
            // Initialize file upload functionality (will load ONLY new files)
            initializeFileUpload();
            initializeMetricsTabs();
            registerMetricCardElements();
            registerGraphValueElements();
            showImportOverlay(0, { mode: 'waiting' });
            
            // Initialize Journalanteckningar card click handler
            initializeJournalCard();
            
            // Initialize session info
            updateSessionTimeRemaining();
            updateFileCount();
            ensureSessionTimerInterval();
            
            // Add escape key listener for logout overlay
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape') {
                    hideLogoutOverlay();
                }
            });
        });

        async function initializeFileUpload() {
            console.log('Dashboard initializeFileUpload - Starting with loading state');
            
            const categoriesContainer = document.getElementById('file-categories');
            const journalContent = document.querySelector('.journal-content');
            
            if (categoriesContainer) {
                categoriesContainer.innerHTML = '<p class="empty-category">Laddar filer...</p>';
            }
            
            // Update patient name from localStorage
            const savedPatientName = localStorage.getItem('currentPatientName');
            if (savedPatientName) {
                const patientNameHeader = document.getElementById('patient-name-header');
                if (patientNameHeader) {
                    patientNameHeader.textContent = `Patient: ${savedPatientName}`;
                    console.log('Updated patient name to:', savedPatientName);
                }
            }
            
            // STEP 4: Get transferId from redirect and load ONLY new files
            const savedTransferId = localStorage.getItem('currentTransferId');
            console.log('Checking for transfer ID from redirect:', savedTransferId);
            
            if (savedTransferId) {
                // Verify the transfer exists on the server and has files
                try {
                    const verifyResponse = await fetch(`/api/files?transferId=${savedTransferId}`, {
                        cache: 'no-store',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache'
                        }
                    });
                    
                    if (verifyResponse.ok) {
                        const verifyData = await verifyResponse.json();
                        console.log('Transfer verification response:', verifyData);
                        console.log('Files in transfer:', verifyData.files?.length || 0);
                        
                        // Always keep the transfer so we can poll for future uploads
                        currentTransferId = savedTransferId;
                        console.log('✅ Transfer verified, monitoring uploads for ID:', currentTransferId);
                        
                        await loadUploadedFiles();
                        startFileEventStream();
                    } else {
                        // Transfer doesn't exist - show empty
                        console.log('Transfer not found on server - showing empty');
                        localStorage.removeItem('currentTransferId');
                        currentTransferId = null;
                        uploadedFiles = [];
                        updateFileDisplay();
                    }
                } catch (error) {
                    console.error('Error verifying transfer:', error);
                    localStorage.removeItem('currentTransferId');
                    currentTransferId = null;
                    uploadedFiles = [];
                    updateFileDisplay();
                }
            } else {
                // No transferId - empty state
                console.log('No transfer ID - showing empty state');
                currentTransferId = null;
                uploadedFiles = [];
                updateFileDisplay();
            }
        }

        function registerMetricCardElements() {
            document.querySelectorAll('[data-metric-card]').forEach(card => {
                const key = card.getAttribute('data-metric-card');
                const valueEl = card.querySelector('.mini-value');
                if (key && valueEl) {
                    metricCardElements[key] = valueEl;
                }
            });
        }

        function registerGraphValueElements() {
            document.querySelectorAll('[data-graph-value]').forEach(element => {
                const key = element.getAttribute('data-graph-value');
                if (key) {
                    graphValueElements[key] = element;
                }
            });
        }

        function resetExcelDrivenUI() {
            resetMiniCards();
            resetGraphValues();
            resetCharts();
            if (currentTransferId) {
                showImportOverlay(0, { mode: 'waiting' });
            } else {
                finishImportOverlay({ immediate: true });
            }
        }

        function resetMiniCards() {
            Object.values(metricCardElements).forEach(el => {
                el.textContent = 'Värde saknas';
            });
        }

        function resetGraphValues() {
            Object.values(graphValueElements).forEach(el => {
                el.textContent = 'Värde saknas';
            });
        }

        function resetCharts() {
            Object.entries(chartCanvasIdMap).forEach(([key, canvasId]) => {
                renderChartOrEmpty(key, canvasId, null, 'Ingen data tillgänglig');
            });
        }

        function applyExcelMetricsToUI(metrics) {
            if (!metrics) {
                resetExcelDrivenUI();
                return;
            }
            updateMiniCardsFromMetrics(metrics.latest);
            updateGraphCardsFromMetrics(metrics);
        }

        function updateMiniCardsFromMetrics(latest) {
            if (!latest) {
                resetMiniCards();
                return;
            }

            if (latest.bloodPressure) {
                const systolic = latest.bloodPressure.systolic ?? '–';
                const diastolic = latest.bloodPressure.diastolic ?? '–';
                setMiniCardValue('bloodPressure', `${systolic}/${diastolic} ${latest.bloodPressure.unit || 'mmHg'}`);
            } else {
                setMiniCardValue('bloodPressure', 'Värde saknas');
            }

            if (latest.heartRate) {
                setMiniCardValue('heartRate', `${formatNumericValue(latest.heartRate.value, 0) || latest.heartRate.value} bpm`);
            } else {
                setMiniCardValue('heartRate', 'Värde saknas');
            }

            if (latest.oxygenSaturation) {
                setMiniCardValue('oxygen', `${formatNumericValue(latest.oxygenSaturation.value, 0) || latest.oxygenSaturation.value}%`);
            } else {
                setMiniCardValue('oxygen', 'Värde saknas');
            }

            if (latest.weight) {
                const unit = latest.weight.unit || 'kg';
                setMiniCardValue('weight', `${formatNumericValue(latest.weight.value) || latest.weight.value} ${unit}`);
            } else {
                setMiniCardValue('weight', 'Värde saknas');
            }

            if (latest.steps) {
                setMiniCardValue('steps', `${formatNumericValue(latest.steps.value, 0) || latest.steps.value} steg`);
            } else {
                setMiniCardValue('steps', 'Värde saknas');
            }
        }

        function setMiniCardValue(key, text) {
            if (metricCardElements[key]) {
                metricCardElements[key].textContent = text || 'Värde saknas';
            }
        }

        function updateGraphCardsFromMetrics(metrics) {
            const trends = metrics.trends || {};
            const latest = metrics.latest || {};

            updateBloodPressureChart(trends.bloodPressure || [], latest.bloodPressure);
            updateHeartRateChart(trends.heartRate || [], trends.afBurden || [], latest.heartRate, latest.afBurden);
            updateWeightChart(trends.weight || [], latest.weight);
            updateOxygenChart(trends.oxygenSaturation || [], latest.oxygenSaturation);
            updateRiskLabChart(metrics);
            updateGlucoseChart(trends.glucose || [], latest.glucose);
            updateEgfrChart(trends.egfr || [], latest.egfr);
        }

        function updateBloodPressureChart(entries, latest) {
            const canvasId = chartCanvasIdMap.bloodPressure;
            if (!canvasId) return;

            if (!Array.isArray(entries) || !entries.length) {
                renderChartOrEmpty('bloodPressure', canvasId, null, 'Ingen data tillgänglig');
                setGraphValueText('bloodPressure', 'Värde saknas');
                return;
            }

            const timeline = buildTimelineLabels([entries]);
            const systolicData = mapEntriesToSeries(timeline.keys, entries, entry => entry.systolic ?? null);
            const diastolicData = mapEntriesToSeries(timeline.keys, entries, entry => entry.diastolic ?? null);

            renderChartOrEmpty('bloodPressure', canvasId, {
                labels: timeline.labels,
                datasets: [
                    {
                        label: 'Systoliskt',
                        data: systolicData,
                        borderColor: '#f97316',
                        backgroundColor: 'rgba(249,115,22,0.15)',
                        tension: 0.35,
                        fill: false,
                        spanGaps: true
                    },
                    {
                        label: 'Diastoliskt',
                        data: diastolicData,
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16,185,129,0.15)',
                        tension: 0.35,
                        fill: false,
                        spanGaps: true
                    }
                ]
            });

            if (latest) {
                const systolic = latest.systolic ?? '–';
                const diastolic = latest.diastolic ?? '–';
                setGraphValueText('bloodPressure', `${systolic}/${diastolic} ${latest.unit || 'mmHg'}`);
            } else {
                setGraphValueText('bloodPressure', 'Värde saknas');
            }
        }

        function updateHeartRateChart(hrEntries, afEntries, latestHeartRate, latestAf) {
            const canvasId = chartCanvasIdMap.heartRate;
            if (!canvasId) return;

            if ((!Array.isArray(hrEntries) || !hrEntries.length) && (!Array.isArray(afEntries) || !afEntries.length)) {
                renderChartOrEmpty('heartRate', canvasId, null, 'Ingen data tillgänglig');
                setGraphValueText('heartRate', 'Värde saknas');
                return;
            }

            const hrSeries = maybeAggregateTrendSeries(hrEntries);
            const afSeries = maybeAggregateTrendSeries(afEntries);
            const timeline = buildTimelineLabels([hrSeries, afSeries]);
            const datasets = [];

            if (hrSeries.length) {
                datasets.push({
                    label: 'Hjärtfrekvens',
                    data: mapEntriesToSeries(timeline.keys, hrSeries, entry => entry.value ?? null),
                    borderColor: '#2563eb',
                    backgroundColor: 'rgba(37,99,235,0.15)',
                    tension: 0.35,
                    fill: true,
                    spanGaps: true,
                    yAxisID: 'y'
                });
            }

            if (afSeries.length) {
                datasets.push({
                    label: 'AF-börda',
                    data: mapEntriesToSeries(timeline.keys, afSeries, entry => entry.value ?? null),
                    borderColor: '#f87171',
                    backgroundColor: 'rgba(248,113,113,0.1)',
                    tension: 0.35,
                    fill: false,
                    spanGaps: true,
                    yAxisID: 'y1'
                });
            }

            renderChartOrEmpty('heartRate', canvasId, {
                labels: timeline.labels,
                datasets,
                showLegend: datasets.length > 1,
                options: {
                    scales: {
                        y: {
                            beginAtZero: false,
                            grid: { color: 'rgba(0,0,0,0.08)' },
                            title: { display: datasets.length > 0, text: 'bpm' }
                        },
                        y1: {
                            beginAtZero: true,
                            min: 0,
                            max: 100,
                            position: 'right',
                            grid: { drawOnChartArea: false },
                            title: { display: datasets.length > 1, text: '%' }
                        }
                    }
                }
            });

            if (latestHeartRate) {
                let valueText = `${formatNumericValue(latestHeartRate.value, 0) || latestHeartRate.value} bpm`;
                if (latestAf && typeof latestAf.value === 'number') {
                    valueText += ` • AF ${formatNumericValue(latestAf.value, 0)}%`;
                }
                setGraphValueText('heartRate', valueText);
            } else if (latestAf) {
                setGraphValueText('heartRate', `AF ${formatNumericValue(latestAf.value, 0)}%`);
            } else {
                setGraphValueText('heartRate', 'Värde saknas');
            }
        }

        function updateWeightChart(entries, latest) {
            const canvasId = chartCanvasIdMap.weight;
            if (!canvasId) return;

            if (!Array.isArray(entries) || !entries.length) {
                renderChartOrEmpty('weight', canvasId, null, 'Ingen data tillgänglig');
                setGraphValueText('weight', 'Värde saknas');
                return;
            }

            const timeline = buildTimelineLabels([entries]);
            renderChartOrEmpty('weight', canvasId, {
                labels: timeline.labels,
                datasets: [{
                    label: 'Vikt',
                    data: mapEntriesToSeries(timeline.keys, entries, entry => entry.value ?? null),
                    borderColor: '#0ea5e9',
                    backgroundColor: 'rgba(14,165,233,0.2)',
                    tension: 0.35,
                    fill: true,
                    spanGaps: true
                }]
            });

            if (latest) {
                setGraphValueText('weight', `${formatNumericValue(latest.value) || latest.value} ${latest.unit || 'kg'}`);
            } else {
                setGraphValueText('weight', 'Värde saknas');
            }
        }

        function updateOxygenChart(entries, latest) {
            const canvasId = chartCanvasIdMap.oxygen;
            if (!canvasId) return;

            if (!Array.isArray(entries) || !entries.length) {
                setGraphCardTitle('ntprobnp', 'NT-proBNP');
                renderChartOrEmpty('oxygen', canvasId, null, 'Ingen data tillgänglig');
                setGraphValueText('ntprobnp', 'Värde saknas');
                return;
            }

            setGraphCardTitle('ntprobnp', 'Syresättning över tid');

            const timeline = buildTimelineLabels([entries]);
            renderChartOrEmpty('oxygen', canvasId, {
                labels: timeline.labels,
                datasets: [{
                    label: 'SpO₂',
                    data: mapEntriesToSeries(timeline.keys, entries, entry => entry.value ?? null),
                    borderColor: '#14b8a6',
                    backgroundColor: 'rgba(20,184,166,0.2)',
                    tension: 0.35,
                    fill: true,
                    spanGaps: true
                }],
                options: {
                    scales: {
                        y: {
                            suggestedMin: 80,
                            suggestedMax: 100,
                            ticks: {
                                callback: value => `${value}%`
                            }
                        }
                    }
                }
            });

            if (latest) {
                setGraphValueText('ntprobnp', `${formatNumericValue(latest.value, 0) || latest.value}%`);
            } else {
                setGraphValueText('ntprobnp', 'Värde saknas');
            }
        }

        function updateRiskLabChart(metrics) {
            const canvasId = chartCanvasIdMap.ldl;
            if (!canvasId) return;

            const seriesConfig = [
                { key: 'ldl', label: 'LDL', short: 'LDL', color: '#ef4444' },
                { key: 'hdl', label: 'HDL', short: 'HDL', color: '#3b82f6' },
                { key: 'totalCholesterol', label: 'Totalkolesterol', short: 'Tot', color: '#a855f7' },
                { key: 'triglycerides', label: 'Triglycerider', short: 'TG', color: '#f59e0b' }
            ];

            const datasets = [];
            const availableTrends = [];

            seriesConfig.forEach(config => {
                const entries = metrics.trends?.[config.key];
                if (Array.isArray(entries) && entries.length) {
                    availableTrends.push(entries);
                }
            });

            if (!availableTrends.length) {
                renderChartOrEmpty('ldl', canvasId, null, 'Ingen data tillgänglig');
                setGraphValueText('ldl', 'Värde saknas');
                return;
            }

            const timeline = buildTimelineLabels(availableTrends);

            seriesConfig.forEach(config => {
                const entries = metrics.trends?.[config.key];
                if (!Array.isArray(entries) || !entries.length) return;
                datasets.push({
                    label: config.label,
                    data: mapEntriesToSeries(timeline.keys, entries, entry => entry.value ?? null),
                    borderColor: config.color,
                    backgroundColor: config.color + '33',
                    tension: 0.35,
                    fill: false,
                    spanGaps: true
                });
            });

            renderChartOrEmpty('ldl', canvasId, {
                labels: timeline.labels,
                datasets,
                showLegend: true
            });

            const summaryPieces = [];
            seriesConfig.forEach(config => {
                const latest = metrics.latest?.[config.key];
                if (latest && typeof latest.value === 'number') {
                    const numeric = formatNumericValue(latest.value) || latest.value;
                    summaryPieces.push(`${config.short || config.label} ${numeric}`);
                }
            });
            if (summaryPieces.length) {
                setGraphValueBadges('ldl', summaryPieces);
            } else {
                setGraphValueText('ldl', 'Värde saknas');
            }
        }

        function updateGlucoseChart(entries, latest) {
            const canvasId = chartCanvasIdMap.glucose;
            if (!canvasId) return;

            if (!Array.isArray(entries) || !entries.length) {
                renderChartOrEmpty('glucose', canvasId, null, 'Ingen data tillgänglig');
                setGraphValueText('glucose', 'Värde saknas');
                return;
            }

            const timeline = buildTimelineLabels([entries]);
            renderChartOrEmpty('glucose', canvasId, {
                labels: timeline.labels,
                datasets: [{
                    label: 'HbA1c / Glukos',
                    data: mapEntriesToSeries(timeline.keys, entries, entry => entry.value ?? null),
                    borderColor: '#9333ea',
                    backgroundColor: 'rgba(147,51,234,0.15)',
                    tension: 0.35,
                    fill: true,
                    spanGaps: true
                }]
            });

            if (latest) {
                setGraphValueText('glucose', `${formatNumericValue(latest.value) || latest.value} ${latest.unit || 'mmol/L'}`);
            } else {
                setGraphValueText('glucose', 'Värde saknas');
            }
        }

        function updateEgfrChart(entries, latest) {
            const canvasId = chartCanvasIdMap.egfr;
            if (!canvasId) return;

            if (!Array.isArray(entries) || !entries.length) {
                renderChartOrEmpty('egfr', canvasId, null, 'Ingen data tillgänglig');
                setGraphValueText('egfr', 'Värde saknas');
                return;
            }

            const timeline = buildTimelineLabels([entries]);
            renderChartOrEmpty('egfr', canvasId, {
                labels: timeline.labels,
                datasets: [{
                    label: 'eGFR',
                    data: mapEntriesToSeries(timeline.keys, entries, entry => entry.value ?? null),
                    borderColor: '#0f172a',
                    backgroundColor: 'rgba(15,23,42,0.15)',
                    tension: 0.35,
                    fill: true,
                    spanGaps: true
                }]
            });

            if (latest) {
                setGraphValueText('egfr', `${formatNumericValue(latest.value) || latest.value} ${latest.unit || 'mL/min'}`);
            } else {
                setGraphValueText('egfr', 'Värde saknas');
            }
        }

        function setGraphValueText(key, text) {
            const target = graphValueElements[key];
            if (!target) return;
            target.classList.remove('graph-value-multi');
            target.innerHTML = '';
            target.textContent = text || 'Värde saknas';
        }

        function setGraphValueBadges(key, items) {
            const target = graphValueElements[key];
            if (!target) return;
            if (!Array.isArray(items) || !items.length) {
                setGraphValueText(key, 'Värde saknas');
                return;
            }
            target.classList.add('graph-value-multi');
            target.innerHTML = items.map(item => `<span class="graph-value-badge">${item}</span>`).join('');
        }

        function setGraphCardTitle(chartKey, title) {
            const header = document.querySelector(`[data-chart-key="${chartKey}"] .graph-card-header h3`);
            if (header && title) {
                header.textContent = title;
            }
        }

        function renderChartOrEmpty(key, canvasId, config, emptyMessage = 'Ingen data tillgänglig') {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            if (dashboardCharts[key]) {
                dashboardCharts[key].destroy();
                dashboardCharts[key] = null;
            }

            if (!config || !config.labels || !config.datasets || config.datasets.every(ds => !ds || !Array.isArray(ds.data) || ds.data.every(value => value === null || typeof value === 'undefined'))) {
                dashboardCharts[key] = new Chart(ctx, createEmptyChartConfig(emptyMessage, config?.type || 'line'));
                return;
            }

            dashboardCharts[key] = new Chart(ctx, {
                type: config.type || 'line',
                data: {
                    labels: config.labels,
                    datasets: config.datasets
                },
                options: Object.assign({
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { display: config.showLegend !== false },
                        tooltip: { intersect: false }
                    },
                    scales: config.options?.scales || {
                        x: { grid: { display: false } },
                        y: { grid: { color: 'rgba(0,0,0,0.08)' }, beginAtZero: false }
                    }
                }, config.options || {})
            });
        }

        function createEmptyChartConfig(message, type) {
            return {
                type: type || 'line',
                data: { labels: [], datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: { display: false },
                        y: { display: false }
                    }
                },
                plugins: [{
                    id: 'empty-state',
                    afterDraw: chart => {
                        const ctx = chart.ctx;
                        const { width, height } = chart;
                        ctx.save();
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.font = '14px system-ui';
                        ctx.fillStyle = '#9ca3af';
                        ctx.fillText(message, width / 2, height / 2);
                        ctx.restore();
                    }
                }]
            };
        }

        function buildTimelineLabels(entryGroups) {
            const keys = [];
            entryGroups.forEach(group => {
                if (!Array.isArray(group)) return;
                group.forEach((entry, index) => {
                    const key = buildLabelKey(entry, index);
                    if (!keys.includes(key)) {
                        keys.push(key);
                    }
                });
            });

            keys.sort((a, b) => {
                const isOrderA = a.startsWith('order-') || a.startsWith('row-');
                const isOrderB = b.startsWith('order-') || b.startsWith('row-');
                if (isOrderA && isOrderB) {
                    return a.localeCompare(b, undefined, { numeric: true });
                }
                if (isOrderA) return 1;
                if (isOrderB) return -1;
                return new Date(a) - new Date(b);
            });

            return {
                keys,
                labels: keys.map(formatTimestampLabel)
            };
        }

        function buildLabelKey(entry, index) {
            if (entry?.timestamp) return entry.timestamp;
            if (typeof entry?.order !== 'undefined') {
                return `order-${entry.order}`;
            }
            return `row-${index}`;
        }

        function mapEntriesToSeries(labelKeys, entries, getter) {
            const lookup = new Map();
            entries.forEach((entry, index) => {
                const key = buildLabelKey(entry, index);
                if (!lookup.has(key)) {
                    lookup.set(key, getter(entry));
                }
            });
            return labelKeys.map(key => lookup.has(key) ? lookup.get(key) : null);
        }

        function formatTimestampLabel(key) {
            if (!key) return '';
            if (key.startsWith('order-') || key.startsWith('row-')) {
                return key.replace(/^(order|row)-/, 'Mätning ');
            }
            const date = new Date(key);
            if (Number.isNaN(date.valueOf())) return key;
            return date.toLocaleDateString('sv-SE', { month: 'short', day: 'numeric' });
        }

        const MAX_HEART_RATE_POINTS = 60;

        function maybeAggregateTrendSeries(entries, options = {}) {
            if (!Array.isArray(entries) || !entries.length) return [];
            const { maxPoints = MAX_HEART_RATE_POINTS } = options;
            if (entries.length <= maxPoints) {
                return entries;
            }
            if (!entries.some(entry => entry?.timestamp)) {
                return entries;
            }
            const buckets = new Map();
            entries.forEach(entry => {
                const bucketKey = getMonthlyBucketKey(entry.timestamp);
                if (!bucketKey) return;
                const bucket = buckets.get(bucketKey) || {
                    key: bucketKey,
                    sum: 0,
                    count: 0,
                    template: entry
                };
                const value = typeof entry.value === 'number' ? entry.value : null;
                if (value !== null && !Number.isNaN(value)) {
                    bucket.sum += value;
                    bucket.count += 1;
                }
                buckets.set(bucketKey, bucket);
            });
            const aggregated = [];
            buckets.forEach(bucket => {
                const avg = bucket.count ? bucket.sum / bucket.count : null;
                aggregated.push({
                    ...bucket.template,
                    value: avg,
                    timestamp: buildBucketTimestamp(bucket.key)
                });
            });
            return aggregated.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        }

        function getMonthlyBucketKey(timestamp) {
            if (!timestamp) return null;
            const date = new Date(timestamp);
            if (Number.isNaN(date.valueOf())) return null;
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            return `${year}-${month}`;
        }

        function buildBucketTimestamp(bucketKey) {
            if (!bucketKey) return null;
            return `${bucketKey}-01T00:00:00.000Z`;
        }

        function formatNumericValue(value, decimals = 1) {
            if (value === null || value === undefined) return null;
            const number = Number(value);
            if (Number.isNaN(number)) return null;
            return number.toLocaleString('sv-SE', {
                minimumFractionDigits: 0,
                maximumFractionDigits: decimals
            });
        }

        function combineExcelMetrics(metricList) {
            if (!Array.isArray(metricList) || !metricList.length) return null;
            const combined = createEmptyCombinedMetrics();

            metricList.forEach(metrics => {
                if (!metrics) return;
                mergeBloodPressureLatest(combined.latest, metrics.latest?.bloodPressure);

                const numericKeys = [
                    'heartRate',
                    'oxygenSaturation',
                    'weight',
                    'ldl',
                    'hdl',
                    'totalCholesterol',
                    'triglycerides',
                    'glucose',
                    'egfr',
                    'steps',
                    'sleep',
                    'afBurden'
                ];

                numericKeys.forEach(key => {
                    mergeLatestMetric(combined.latest, metrics.latest, key);
                    mergeTrendSeries(combined.trends, metrics.trends, key);
                });

                mergeTrendSeries(combined.trends, metrics.trends, 'bloodPressure');
            });

            Object.values(combined.trends).forEach(entries => {
                if (!Array.isArray(entries)) return;
                entries.sort((a, b) => {
                    const keyA = a.timestamp || a.order || 0;
                    const keyB = b.timestamp || b.order || 0;
                    return new Date(keyA) - new Date(keyB);
                });
            });

            return combined;
        }

        function createEmptyCombinedMetrics() {
            return {
                latest: {
                    bloodPressure: null,
                    heartRate: null,
                    oxygenSaturation: null,
                    weight: null,
                    ldl: null,
                    hdl: null,
                    totalCholesterol: null,
                    triglycerides: null,
                    glucose: null,
                    egfr: null,
                    steps: null,
                    sleep: null,
                    afBurden: null
                },
                trends: {
                    bloodPressure: [],
                    heartRate: [],
                    oxygenSaturation: [],
                    weight: [],
                    ldl: [],
                    hdl: [],
                    totalCholesterol: [],
                    triglycerides: [],
                    glucose: [],
                    egfr: [],
                    steps: [],
                    sleep: [],
                    afBurden: []
                }
            };
        }

        function mergeBloodPressureLatest(targetLatest, candidate) {
            if (!candidate) return;
            const current = targetLatest.bloodPressure;
            if (!current || isCandidateNewer(current, candidate)) {
                targetLatest.bloodPressure = candidate;
            }
        }

        function mergeLatestMetric(targetLatest, sourceLatest, key) {
            const candidate = sourceLatest?.[key];
            if (!candidate) return;
            const current = targetLatest[key];
            if (!current || isCandidateNewer(current, candidate)) {
                targetLatest[key] = candidate;
            }
        }

        function mergeTrendSeries(targetTrends, sourceTrends, key) {
            if (!sourceTrends || !Array.isArray(sourceTrends[key]) || !sourceTrends[key].length) return;
            targetTrends[key] = targetTrends[key] || [];
            targetTrends[key].push(...sourceTrends[key]);
        }

        function isCandidateNewer(current, candidate) {
            if (!candidate) return false;
            if (!current) return true;
            if (candidate.timestamp && current.timestamp) {
                return new Date(candidate.timestamp) >= new Date(current.timestamp);
            }
            if (candidate.timestamp && !current.timestamp) return true;
            if (!candidate.timestamp && current.timestamp) return false;
            return (candidate.order || 0) >= (current.order || 0);
        }

        async function loadUploadedFiles() {
            if (!currentTransferId) {
                console.log('No transfer ID available for loading files');
                uploadedFiles = [];
                updateFileDisplay();
                // Clear overlay flag so it shows again when files are uploaded
                localStorage.removeItem(DASHBOARD_WAITING_OVERLAY_KEY);
                finishImportOverlay({ immediate: true });
                return;
            }

            console.log('Loading files for transfer ID:', currentTransferId);
            
            try {
                // Load files ONLY from API endpoint (in-memory server state)
                // NEVER load from localStorage, blob storage, or any persistent storage
                // The server will return empty array if transfer was cleared by logout
                const url = `/api/files?transferId=${currentTransferId}`;
                console.log('Fetching files from API:', url);
                
                const response = await fetch(url, {
                    method: 'GET',
                    cache: 'no-store',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache'
                    }
                });
                console.log('API response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.status === 'cancelled') {
                        handleSessionTerminatedByPatient();
                        return;
                    }
                    console.log('Loaded files data from API:', data);
                    console.log('Files array:', data.files);
                    
                    // CRITICAL: Trust the server - if it returns files, they're from current session
                    // Server ensures all transfers are cleared on logout, so files here are current
                    uploadedFiles = data.files || [];
                    console.log('✅ Number of files loaded from API:', uploadedFiles.length);
                    console.log('Files details:', uploadedFiles);
                    lastServerFileCount = uploadedFiles.length;
                    
                    // Display files if we have any
                    if (uploadedFiles.length > 0) {
                        console.log('✅ Files found on initial load:', uploadedFiles.length);
                        
                        // Clear old localStorage file data before saving new
                        Object.keys(localStorage).forEach(key => {
                            if (key.startsWith('mmd_files_') || key === 'uploadedFiles') {
                                localStorage.removeItem(key);
                            }
                        });
                        
                        saveFilesToStorage(); // Save to localStorage for this session
                        updateFileDisplay();
                        updateFileCount();
                        updateProvsvarStatus();
                        
                        // Hide waiting overlay immediately since we have files
                        markWaitingOverlaySeen();
                        if (importOverlayState.mode === 'waiting') {
                            finishImportOverlay({ immediate: true });
                        }
                        
                        // Show notification for mobile files
                        showFileNotification({ size: 0 }); // Special notification for mobile files
                        
                        // Load imported journal notes if any PDF files exist
                        await loadImportedJournalNotes();
                        
                        // Load Excel insights - this will show/hide the import overlay as needed
                        await loadExcelInsights(uploadedFiles);
                    } else {
                        // No files found - ensure everything is cleared
                        uploadedFiles = [];
                        lastServerFileCount = 0; // Reset count so we can detect new files
                        updateFileDisplay();
                        updateFileCount();
                        updateProvsvarStatus();
                        console.log('No files found for this transfer - clean state');
                        // Clear overlay flag so it shows again when files are uploaded
                        localStorage.removeItem(DASHBOARD_WAITING_OVERLAY_KEY);
                        if (currentTransferId) {
                            showImportOverlay(0, { mode: 'waiting' });
                        } else {
                            finishImportOverlay({ immediate: true });
                        }
                        await loadExcelInsights([]);
                    }
                } else {
                    const errorText = await response.text();
                    console.error('Failed to load files from API, status:', response.status);
                    console.error('Error response:', errorText);
                    
                    // API failed - clear everything
                    uploadedFiles = [];
                    lastServerFileCount = 0;
                    updateFileDisplay();
                    updateFileCount();
                    updateProvsvarStatus();
                    console.log('API failed - cleared all data');
                    if (currentTransferId) {
                        showImportOverlay(0, { mode: 'waiting' });
                    } else {
                        finishImportOverlay({ immediate: true });
                    }
                    await loadExcelInsights([]);
                }
            } catch (error) {
                console.error('Failed to load uploaded files from mobile app:', error);
                // On error - clear everything
                uploadedFiles = [];
                lastServerFileCount = 0;
                updateFileDisplay();
                updateFileCount();
                updateProvsvarStatus();
                if (currentTransferId) {
                    showImportOverlay(0, { mode: 'waiting' });
                } else {
                    finishImportOverlay({ immediate: true });
                }
                await loadExcelInsights([]);
            }
        }

        async function loadImportedJournalNotes() {
            if (!currentTransferId) return;
            
            // Find PDF files in the uploaded files
            const pdfFiles = uploadedFiles.filter(file => 
                file.mimetype === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')
            );
            
            const journalContent = document.querySelector('.journal-content');
            
            if (pdfFiles.length > 0) {
                // Clear existing PDF cards and empty state
                journalContent.innerHTML = '';
                
                // Create a card for each PDF file
                for (const pdfFile of pdfFiles) {
                    try {
                        // Load PDF content from mobile app
                        const response = await fetch(`/api/pdf-content?transferId=${currentTransferId}&filename=${encodeURIComponent(pdfFile.name)}`);
                        
                        if (response.ok) {
                            const parsedData = await response.json();
                            const pdfCard = createPDFJournalCard(pdfFile, parsedData);
                            journalContent.appendChild(pdfCard);
                        } else {
                            console.error(`Failed to load PDF content for ${pdfFile.name}, status:`, response.status);
                            // Create a basic card even if content loading fails
                            const basicCard = createBasicPDFCard(pdfFile);
                            journalContent.appendChild(basicCard);
                        }
                    } catch (error) {
                        console.error(`Failed to load PDF content for ${pdfFile.name}:`, error);
                        // Create a basic card even if content loading fails
                        const basicCard = createBasicPDFCard(pdfFile);
                        journalContent.appendChild(basicCard);
                    }
                }
            } else {
                showEmptyJournalState();
            }
        }

        function formatStructuredContent(content) {
            // If content is a string (old format), return it as is
            if (typeof content === 'string') {
                return `<h4>Importerad Journalanteckning</h4><p>${content}</p>`;
            }
            
            // If content is structured (new format), show sections with proper hierarchy
            if (typeof content === 'object' && content !== null) {
                let html = '<h4>Importerad Journalanteckning</h4>';
                
                // Check if it's the new structured format with sections array
                if (content.sections && Array.isArray(content.sections)) {
                    // New structured format with sections - simple hierarchy within main card
                    content.sections.forEach(section => {
                        html += `<div style="margin-bottom: 12px;">`;
                        // Match the style of "Importerad Journalanteckning" by using a plain h4 without custom sizing
                        html += `<h4>${section.heading}</h4>`;
                        // Match the style of the summary text above by reusing the journal-summary class
                        html += `<p class="journal-summary">${section.content}</p>`;
                        html += `</div>`;
                    });
                } else {
                    // Old key-based format - combine all content into one readable text
                    let fullContent = '';
                    
                    // Define section order and Swedish labels
                    const sectionOrder = [
                        { key: 'anamnes', label: 'Anamnes' },
                        { key: 'status', label: 'Status' },
                        { key: 'undersokningar', label: 'Undersökningar' },
                        { key: 'bedomning', label: 'Bedömning' },
                        { key: 'rekommendationer', label: 'Rekommendationer' },
                        { key: 'medicin', label: 'Medicin/Behandling' }
                    ];
                    
                    // Add structured sections to full content
                    sectionOrder.forEach(section => {
                        if (content[section.key]) {
                            fullContent += `<strong>${section.label}:</strong> ${content[section.key]}\n\n`;
                        }
                    });
                    
                    // Add other content if any
                    if (content.other && content.other.length > 0) {
                        fullContent += `<strong>Övrig information:</strong> ${content.other.join(' ')}\n\n`;
                    }
                    
                    // Display as single paragraph with line breaks
                    html += `<div class="journal-full-content"><p>${fullContent.replace(/\n\n/g, '</p><p>')}</p></div>`;
                }
                
                return html;
            }
            
            // Fallback
            return `<h4>Importerad Journalanteckning</h4><p>Innehållet kunde inte formateras korrekt.</p>`;
        }

        function createPDFJournalCard(pdfFile, parsedData) {
            const card = document.createElement('div');
            card.className = 'journal-entry pdf-journal-entry';
            card.style.cursor = 'pointer';
            card.onclick = () => showPDFPreview(currentTransferId, encodeURIComponent(pdfFile.name), pdfFile.name);
            
            // Use the parsed data from the server
            const title = parsedData.title || generatePDFTitle(parsedData.content, pdfFile.name);
            const doctor = parsedData.doctor || 'Importerad från PDF';
            const date = parsedData.date || new Date(pdfFile.uploadedAt || Date.now()).toLocaleDateString('sv-SE');
            const summary = parsedData.summary || generatePDFSummary(parsedData.content);
            
            card.innerHTML = `
                <div class="journal-header">
                    <div class="journal-info">
                        <h3 class="journal-title">${title}</h3>
                        <p class="journal-doctor">${doctor}</p>
                        <p class="journal-date">${date}</p>
                        <p class="journal-summary">${summary}</p>
                    </div>
                </div>
            `;
            
            return card;
        }

        function createBasicPDFCard(pdfFile) {
            const card = document.createElement('div');
            card.className = 'journal-entry pdf-journal-entry';
            card.style.cursor = 'pointer';
            card.onclick = () => showPDFPreview(currentTransferId, encodeURIComponent(pdfFile.name), pdfFile.name);
            
            const uploadDate = new Date(pdfFile.uploadedAt || Date.now()).toLocaleDateString('sv-SE');
            
            card.innerHTML = `
                <div class="journal-header">
                    <div class="journal-info">
                        <h3 class="journal-title">${pdfFile.name}</h3>
                        <p class="journal-doctor">Importerad från PDF</p>
                        <p class="journal-date">${uploadDate}</p>
                        <p class="journal-summary">PDF-fil importerad från mobilen. Innehåll kunde inte analyseras.</p>
                    </div>
                </div>
            `;
            
            return card;
        }

        function generatePDFTitle(content, filename) {
            // Try to extract a meaningful title from the content
            if (typeof content === 'object' && content.anamnes) {
                // Look for common medical terms in anamnes
                const anamnes = content.anamnes.toLowerCase();
                if (anamnes.includes('kontroll') || anamnes.includes('uppföljning')) {
                    return 'Uppföljning - ' + extractPatientInfo(content);
                } else if (anamnes.includes('akut') || anamnes.includes('besvär')) {
                    return 'Akutbesök - ' + extractPatientInfo(content);
                } else if (anamnes.includes('operation') || anamnes.includes('kirurgi')) {
                    return 'Operation - ' + extractPatientInfo(content);
                }
            }
            
            // Fallback to filename or generic title
            const cleanFilename = filename.replace(/\.pdf$/i, '').replace(/[_-]/g, ' ');
            return cleanFilename || 'Importerad Journalanteckning';
        }

        function extractPatientInfo(content) {
            if (typeof content === 'object' && content.anamnes) {
                // Try to extract age, gender, or condition from anamnes
                const anamnes = content.anamnes;
                const ageMatch = anamnes.match(/(\d+)\s*år/);
                const genderMatch = anamnes.match(/(man|kvinna|patient)/i);
                
                if (ageMatch && genderMatch) {
                    return `${genderMatch[1]} ${ageMatch[1]} år`;
                } else if (ageMatch) {
                    return `${ageMatch[1]} år`;
                }
            }
            return 'Patient';
        }

        function generatePDFSummary(content) {
            if (typeof content === 'object') {
                if (content.bedömning) {
                    return content.bedömning.substring(0, 80) + (content.bedömning.length > 80 ? '...' : '');
                } else if (content.status) {
                    return content.status.substring(0, 80) + (content.status.length > 80 ? '...' : '');
                } else if (content.anamnes) {
                    return content.anamnes.substring(0, 80) + (content.anamnes.length > 80 ? '...' : '');
                }
            } else if (typeof content === 'string') {
                return content.substring(0, 80) + (content.length > 80 ? '...' : '');
            }
            return 'Importerad journalanteckning från PDF-fil.';
        }

        function replaceJournalEntriesWithImported(importedContent) {
            const journalContent = document.querySelector('.journal-content');
            if (!journalContent) return;
            
            // Create a new journal entry based on imported content
            const newEntry = document.createElement('div');
            newEntry.className = 'journal-entry';
            newEntry.onclick = function() { toggleJournalEntry(this); };
            
            newEntry.innerHTML = `
                <div class="journal-header">
                    <div class="journal-info">
                        <h3 class="journal-title">${importedContent.title}</h3>
                        <p class="journal-doctor">${importedContent.doctor}</p>
                        <p class="journal-date">${importedContent.date}</p>
                        <p class="journal-summary">${importedContent.summary}</p>
                    </div>
                    <div class="chevron">›</div>
                </div>
                <div class="journal-details">
                    <div class="journal-actions">
                        <button class="gpt-summarize-btn" onclick="event.stopPropagation(); summarizeWithGPT(this)">
                            <img src="Assets/halsa-gpt.png" alt="Hälsa+GPT" style="width: 16px; height: 16px;">
                            Summera med Hälsa+GPT
                        </button>
                    </div>
                    <div class="journal-content-detail">
                        ${formatStructuredContent(importedContent.content)}
                    </div>
                </div>
            `;
            
            // Replace all existing journal entries with the imported one
            journalContent.innerHTML = '';
            journalContent.appendChild(newEntry);
        }

        function startFileEventStream() {
            if (!currentTransferId) return;

            // Note: EventSource is not available for cross-origin requests in serverless
            // We'll rely on the polling mechanism from the login page instead
            console.log('EventSource not available for cross-origin serverless apps - using polling instead');
            
            // CRITICAL: Store initial file count to detect NEW uploads only
            // If lastServerFileCount is not set yet, use current uploadedFiles length
            if (lastServerFileCount === undefined || lastServerFileCount === null) {
                lastServerFileCount = uploadedFiles.length;
            }
            console.log('Starting file event stream with current file count:', lastServerFileCount, 'uploadedFiles:', uploadedFiles.length);
            
            // Clear any existing poller before starting a new one
            if (filePollIntervalId) {
                clearInterval(filePollIntervalId);
                filePollIntervalId = null;
            }

            let pollInFlight = false;

            // Start polling for new files every 2 seconds
            const pollForFiles = async () => {
                if (pollInFlight) {
                    return;
                }
                pollInFlight = true;
                try {
                    const response = await fetch(`/api/files?transferId=${currentTransferId}`, {
                        cache: 'no-store',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate'
                        }
                    });
                    if (response.ok) {
                        const data = await response.json();
                        if (data.status === 'cancelled') {
                            handleSessionTerminatedByPatient();
                            return;
                        }
                        const serverFiles = data.files || [];
                        const hasFiles = serverFiles.length > 0;
                        const isNewFiles = serverFiles.length > lastServerFileCount;
                        const isFirstDetection = lastServerFileCount === 0 && hasFiles;
                        
                        console.log('Polling result:', {
                            serverFiles: serverFiles.length,
                            lastCount: lastServerFileCount,
                            hasFiles: hasFiles,
                            isNewFiles: isNewFiles,
                            isFirstDetection: isFirstDetection,
                            currentMode: importOverlayState.mode
                        });
                        
                        // Update if we have files (new or existing) and they differ from what we have
                        if (hasFiles && (isNewFiles || isFirstDetection || JSON.stringify(serverFiles.map(f => f.name)) !== JSON.stringify(uploadedFiles.map(f => f.name)))) {
                            console.log('Updating files display');
                            
                            // Only get the NEW files (after last count) for notifications
                            const newFiles = isNewFiles ? serverFiles.slice(lastServerFileCount) : [];
                            
                            // Show notification for each new file (only once per file)
                            newFiles.forEach(file => {
                                const fileKey = `${file.name}-${file.uploadedAt}`;
                                if (!notifiedFiles.has(fileKey)) {
                                    showFileNotification(file);
                                    notifiedFiles.add(fileKey);
                                }
                            });
                            
                            // Update with all files from server
                            uploadedFiles = serverFiles;
                            saveFilesToStorage();
                            updateFileDisplay();
                            updateFileCount();
                            updateProvsvarStatus();
                            
                            // Hide waiting overlay if we have files
                            markWaitingOverlaySeen();
                            if (importOverlayState.mode === 'waiting') {
                                console.log('Hiding waiting overlay - files detected');
                                finishImportOverlay({ immediate: true });
                            }
                            
                            await loadImportedJournalNotes();
                            // Load Excel insights - this will show/hide the import overlay as needed
                            await loadExcelInsights(uploadedFiles);
                            lastServerFileCount = serverFiles.length;
                        } else if (serverFiles.length < lastServerFileCount) {
                            // Server has fewer files - reset to server state (logout cleared them)
                            console.log('Server has fewer files - resetting to server state');
                            uploadedFiles = serverFiles;
                            updateFileDisplay();
                             updateFileCount();
                             updateProvsvarStatus();
                            lastServerFileCount = serverFiles.length;
                        }
                    }
                } catch (error) {
                    console.error('Failed to poll for new files:', error);
                } finally {
                    pollInFlight = false;
                }
            };
            
            // Poll immediately and then every 2 seconds
            pollForFiles();
            filePollIntervalId = setInterval(pollForFiles, 2000);
        }

        function updateFileDisplay() {
            const categoriesContainer = document.getElementById('file-categories');
            if (!categoriesContainer) {
                return;
            }
            console.log('=== UPDATE FILE DISPLAY ===');
            console.log('Updating file display with', uploadedFiles.length, 'files');
            console.log('Files array:', uploadedFiles);

            if (uploadedFiles.length === 0) {
                console.log('No files to display, showing empty message');
                categoriesContainer.innerHTML = '<p class="empty-category">Inga filer att visa</p>';
                showEmptyJournalState();
                updateProvsvarStatus();
                return;
            }

            // Categorize files by type
            const categorized = categorizeFilesByType(uploadedFiles);
            console.log('Categorized files by type:', categorized);
            
            // Render categories
            categoriesContainer.innerHTML = '';
            
            const categoryConfigs = [
                { key: 'excel', name: 'Data', icon: '' },
                { key: 'pdf', name: 'Journalanteckningar', icon: '' }
            ];

            let totalDisplayed = 0;
            categoryConfigs.forEach(config => {
                const files = categorized[config.key] || [];
                console.log(`Category ${config.name}: ${files.length} files`);
                if (files.length > 0) {
                    const categoryDiv = createCategoryElement(config, files);
                    categoriesContainer.appendChild(categoryDiv);
                    totalDisplayed += files.length;
                }
            });
            
            console.log(`Total files displayed: ${totalDisplayed}`);
            console.log('=== END UPDATE FILE DISPLAY ===');
            updateProvsvarStatus();
            updateFileCount();
        }

        function updateProvsvarStatus() {
            const indicator = document.getElementById('provsvarStatusIndicator');
            const stateEl = document.getElementById('provsvarDataState');
            if (!indicator || !stateEl) return;
            
            const hasExcelData = uploadedFiles.some(file =>
                file.mimetype === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
                file.mimetype === 'application/vnd.ms-excel' ||
                file.name.toLowerCase().endsWith('.xlsx') ||
                file.name.toLowerCase().endsWith('.xls')
            );
            
            indicator.classList.remove('good', 'bad');
            indicator.classList.add(hasExcelData ? 'good' : 'bad');
            stateEl.textContent = hasExcelData ? 'Data tillgänglig' : 'Ingen data tillgänglig';
            
            // Update Journalanteckningar card status
            const journalCards = document.querySelectorAll('.organ-item');
            journalCards.forEach(card => {
                const title = card.querySelector('.organ-name');
                if (title && title.textContent === 'Journalanteckningar') {
                    const indicator = card.querySelector('.status-indicator');
                    const stateEl = card.querySelector('.data-count');
                    if (indicator && stateEl) {
                        const pdfFiles = uploadedFiles.filter(file =>
                            file.mimetype === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')
                        );
                        indicator.classList.remove('good', 'bad', 'neutral');
                        indicator.classList.add(pdfFiles.length > 0 ? 'good' : 'bad');
                        stateEl.textContent = pdfFiles.length > 0 ? `${pdfFiles.length} journalanteckning${pdfFiles.length > 1 ? 'ar' : ''}` : 'Ingen data tillgänglig';
                    }
                }
            });
        }

        async function loadExcelInsights(files) {
            if (!Array.isArray(files) || files.length === 0) {
                excelAnalyticsState.combinedMetrics = null;
                excelAnalyticsState.files = [];
                resetExcelDrivenUI();
                return;
            }

            const analytics = await loadExcelAnalytics(files);
            if (analytics && analytics.combinedMetrics) {
                excelAnalyticsState.combinedMetrics = analytics.combinedMetrics;
                excelAnalyticsState.files = analytics.files;
                applyExcelMetricsToUI(analytics.combinedMetrics);
                // Hide overlay after Excel is loaded
                finishImportOverlay();
            } else {
                excelAnalyticsState.combinedMetrics = null;
                excelAnalyticsState.files = [];
                resetExcelDrivenUI();
                // If we have files but no Excel, hide the waiting overlay
                if (files.length > 0) {
                    finishImportOverlay({ immediate: true });
                }
            }
        }

        async function loadExcelAnalytics(files) {
            if (!currentTransferId || !Array.isArray(files) || !files.length) return null;

            const excelFiles = files.filter(file =>
                file.mimetype === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
                file.mimetype === 'application/vnd.ms-excel' ||
                file.name.toLowerCase().endsWith('.xlsx') ||
                file.name.toLowerCase().endsWith('.xls')
            );

            if (!excelFiles.length) {
                return null;
            }

            showImportOverlay(excelFiles.length, { mode: 'import', force: true });

            const parsedFiles = [];
            let completed = 0;

            for (const file of excelFiles) {
                const cacheKey = getExcelCacheKey(currentTransferId, file.name);
                let parsed = getCachedExcelData(cacheKey, file.uploadedAt);

                if (!parsed) {
                    try {
                        console.log('Loading Excel file:', file.name);
                        const url = `/api/excel-content?transferId=${currentTransferId}&filename=${encodeURIComponent(file.name)}&dash=${Date.now()}`;
                        const resp = await fetch(url, { cache: 'no-store' });
                        if (!resp.ok) {
                            const errorText = await resp.text();
                            console.error(`Failed to load excel data (${resp.status}):`, errorText);
                            throw new Error(`Failed to load excel data (${resp.status}): ${errorText}`);
                        }
                        parsed = await resp.json();
                        console.log('Excel data loaded successfully:', parsed);
                        if (parsed.error) {
                            console.error('Excel parsing error:', parsed.error, parsed.details);
                            continue;
                        }
                        setCachedExcelData(cacheKey, file.uploadedAt, parsed);
                    } catch (error) {
                        console.error('Prefetch excel failed:', error);
                        continue;
                    }
                }

                if (parsed && !parsed.error) {
                    parsedFiles.push({ file, data: parsed });
                }

                completed += 1;
                updateImportOverlayProgress(completed, excelFiles.length);
            }

            finishImportOverlay();

            if (!parsedFiles.length) {
                return null;
            }

            const metricsList = parsedFiles
                .map(entry => entry.data?.metrics)
                .filter(Boolean);

            if (!metricsList.length) {
                return null;
            }

            const combinedMetrics = combineExcelMetrics(metricsList);
            return { combinedMetrics, files: parsedFiles };
        }

        function getExcelCacheKey(transferId, filename) {
            return `excel_cache_${transferId}_${filename}`;
        }

        function getCachedExcelData(cacheKey, uploadedAt) {
            try {
                const cached = localStorage.getItem(cacheKey);
                if (!cached) return null;
                const parsed = JSON.parse(cached);
                if (!parsed || !parsed.data) return null;
                if (uploadedAt && parsed.uploadedAt && parsed.uploadedAt !== uploadedAt) {
                    return null;
                }
                return parsed.data;
            } catch (error) {
                console.warn('Failed to read cached excel data', error);
                return null;
            }
        }

        function setCachedExcelData(cacheKey, uploadedAt, data) {
            try {
                localStorage.setItem(cacheKey, JSON.stringify({ uploadedAt, data }));
            } catch (error) {
                console.warn('Failed to cache excel data', error);
            }
        }

        function createCategoryElement(config, files) {
            const div = document.createElement('div');
            div.className = 'file-category-expandable';
            
            const header = document.createElement('div');
            header.className = 'category-header';
            header.innerHTML = `
                <div class="category-title-row">
                    <h3 class="category-title">${config.name}</h3>
                    <span class="file-count">${files.length}</span>
                </div>
                <div class="chevron">›</div>
            `;
            
            const fileList = document.createElement('div');
            fileList.className = 'file-list-vertical';
            fileList.style.display = 'none'; // Initially hidden
            
            files.forEach(file => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item-vertical';
                
                const fileType = file.mimetype === 'application/pdf' ? 'pdf' : 'excel';
                const fileDate = new Date(file.uploadedAt).toLocaleDateString('sv-SE');
                
                if (fileType === 'pdf') {
                    // For PDFs, create a clickable item that shows preview
                    fileItem.innerHTML = `
                        <div class="file-info" style="cursor: pointer;" onclick="event.stopPropagation(); showPDFPreview('${currentTransferId}', '${encodeURIComponent(file.name)}', '${file.name}')">
                            <div class="file-name file-type-${fileType}">${file.name}</div>
                            <div class="file-details">
                                <span class="file-date">${fileDate}</span>
                                <span class="file-size">${Math.round(file.size/1024)} KB</span>
                            </div>
                        </div>
                    `;
                } else {
                    // For Excel files, just show info
                    fileItem.innerHTML = `
                        <div class="file-info">
                            <div class="file-name file-type-${fileType}">${file.name}</div>
                            <div class="file-details">
                                <span class="file-date">${fileDate}</span>
                                <span class="file-size">${Math.round(file.size/1024)} KB</span>
                            </div>
                        </div>
                    `;
                }
                
                fileList.appendChild(fileItem);
            });
            
            // Add click handler for expand/collapse
            header.addEventListener('click', () => {
                const isExpanded = fileList.style.display !== 'none';
                fileList.style.display = isExpanded ? 'none' : 'flex';
                div.classList.toggle('expanded', !isExpanded);
            });
            
            div.appendChild(header);
            div.appendChild(fileList);
            
            return div;
        }

        function categorizeFilesByType(files) {
            console.log('=== CATEGORIZING FILES ===');
            console.log('Input files:', files);
            
            const categories = {
                excel: [],
                pdf: []
            };

            files.forEach(file => {
                console.log('Processing file:', file.name, 'mimetype:', file.mimetype);
                
                if (file.mimetype === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || 
                    file.name.toLowerCase().endsWith('.xlsx')) {
                    console.log('File categorized as Excel:', file.name);
                    categories.excel.push(file);
                } else if (file.mimetype === 'application/pdf' || 
                           file.name.toLowerCase().endsWith('.pdf')) {
                    console.log('File categorized as PDF:', file.name);
                    categories.pdf.push(file);
                } else {
                    // Default to PDF for unknown types
                    console.log('File categorized as PDF (default):', file.name);
                    categories.pdf.push(file);
                }
            });

            console.log('Final categories:', categories);
            console.log('=== END CATEGORIZING FILES ===');
            return categories;
        }

        function categorizeFiles(files) {
            const categories = {
                heart: [],
                bp: [],
                glucose: [],
                activity: [],
                notes: [],
                other: []
            };

            files.forEach(file => {
                const name = file.name.toLowerCase();
                let categorized = false;

                // Heart-related files
                if (/\b(ecg|ekg|heart|cardio|pulse|hjärta|hjärt)\b/.test(name)) {
                    categories.heart.push(file);
                    categorized = true;
                }
                // Blood pressure files
                else if (/\b(bp|blood[- ]?pressure|systolic|diastolic|blodtryck)\b/.test(name)) {
                    categories.bp.push(file);
                    categorized = true;
                }
                // Glucose/blood sugar files
                else if (/\b(glucose|bg|cgm|hba1c|a1c|glukos|blodsocker)\b/.test(name)) {
                    categories.glucose.push(file);
                    categorized = true;
                }
                // Activity/fitness files
                else if (/\b(steps|activity|workout|hrv|vo2|fitness|aktivitet|träning)\b/.test(name)) {
                    categories.activity.push(file);
                    categorized = true;
                }
                // Notes/journal files
                else if (/\b(note|journal|anteckning|anteckningar|journalanteckningar|notat)\b/.test(name)) {
                    categories.notes.push(file);
                    categorized = true;
                }

                if (!categorized) {
                    categories.other.push(file);
                }
            });

            return categories;
        }

        function showFileNotification(file) {
            // Create a temporary notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 24px;
                right: 24px;
                background: #0f172a;
                color: white;
                padding: 16px 24px;
                border-radius: 14px;
                border: 1px solid rgba(148,163,184,0.25);
                box-shadow: 0 20px 40px rgba(15,23,42,0.35);
                z-index: 10000;
                font-size: 14px;
                max-width: 500px;
                white-space: nowrap;
                animation: slideIn 0.3s ease-out;
            `;
            
            if (file.size === 0) {
                notification.remove();
                return;
            } else {
                notification.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="width: 12px; height: 12px; background: #10B981; border-radius: 50%; flex-shrink: 0;"></div>
                        <div>
                            <div style="font-weight: 600;">Ny fil mottagen</div>
                            <div style="font-size: 12px; color: #94a3b8;">${file.name}</div>
                        </div>
                    </div>
                `;
            }
            
            // Add CSS animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            // Remove after 4 seconds
            setTimeout(() => {
                notification.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => {
                    notification.remove();
                    style.remove();
                }, 300);
            }, 4000);
        }

        function handleSessionTerminatedByPatient() {
            sessionStorage.setItem('session_notice', 'Patienten har avslutat sessionen');
            clearAllFiles();
            localStorage.removeItem('sessionStartTime');
            localStorage.removeItem('currentTransferId');
            localStorage.removeItem('currentPatientName');
            window.location.href = 'login.html';
        }

        async function refreshUploadedFiles() {
            await loadUploadedFiles();
        }

        function saveFilesToStorage() {
            // Save uploaded files to localStorage so they persist
            localStorage.setItem('uploadedFiles', JSON.stringify(uploadedFiles));
            console.log('Saved', uploadedFiles.length, 'files to localStorage');
        }

        function loadFilesFromStorage() {
            // Load previously saved files from localStorage
            const savedFiles = localStorage.getItem('uploadedFiles');
            if (savedFiles) {
                uploadedFiles = JSON.parse(savedFiles);
                console.log('Loaded', uploadedFiles.length, 'files from localStorage');
                updateFileDisplay();
                
                // Also load journal notes if there are PDF files
                const pdfFiles = uploadedFiles.filter(file => 
                    file.mimetype === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')
                );
                if (pdfFiles.length > 0) {
                    loadImportedJournalNotes();
                } else {
                    showEmptyJournalState();
                }
            } else {
                showEmptyJournalState();
            }
        }

        function updateFileCount() {
            const fileCountEl = document.getElementById('fileCountValue');
            if (fileCountEl) {
                fileCountEl.textContent = uploadedFiles.length.toString();
            }
        }

        function showEmptyJournalState() {
            const journalContent = document.querySelector('.journal-content');
            if (journalContent && journalContent.children.length === 0) {
                journalContent.innerHTML = `
                    <div class="empty-journal-state">
                        <p>Inga journalanteckningar tillgängliga ännu.</p>
                        <p class="empty-hint">Ladda upp PDF-filer från din mobil för att se importerade journalanteckningar här.</p>
                    </div>
                `;
            }
        }

        function clearAllFiles() {
            // Clear all saved files (for logout or manual clear)
            uploadedFiles = [];
            lastServerFileCount = 0;
            
            // Clear ALL localStorage file data
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('mmd_files_') || key === 'uploadedFiles' || key.startsWith('excel_cache_')) {
                    localStorage.removeItem(key);
                    console.log('clearAllFiles cleared:', key);
                }
            });
            
            // CRITICAL: Clear the file display immediately to remove any old files (Excel, PDF, etc.)
            const categoriesContainer = document.getElementById('file-categories');
            if (categoriesContainer) {
                categoriesContainer.innerHTML = '<p class="empty-category">Inga filer att visa</p>';
            }
            
            // Clear journal content
            const journalContent = document.querySelector('.journal-content');
            if (journalContent) {
                journalContent.innerHTML = '';
            }
            
            updateFileDisplay();
            showEmptyJournalState();
            updateProvsvarStatus();
            
            console.log('Cleared all files and localStorage');
        }

        async function performDeleteUploads(selectedIds = null) {
            if (!uploadedFiles.length) {
                showEmptyJournalState();
                updateProvsvarStatus();
                return;
            }
            const transferToDelete = currentTransferId || localStorage.getItem('currentTransferId');
            
            if (!selectedIds || selectedIds.length === uploadedFiles.length) {
                clearAllFiles();
                showEmptyJournalState();
                updateProvsvarStatus();
                
                if (transferToDelete) {
                    try {
                        await fetch(`/delete-all/${transferToDelete}`, { method: 'DELETE' });
                        console.log('Deleted files for transfer:', transferToDelete);
                    } catch (error) {
                        console.warn('Failed to delete transfer files on server (expected on Vercel):', error);
                    }
                }
                return;
            }
            
            uploadedFiles = uploadedFiles.filter(file => !selectedIds.includes(file.name));
            saveFilesToStorage();
            updateFileDisplay();
            await loadImportedJournalNotes();
            updateProvsvarStatus();
            
            if (transferToDelete) {
                try {
                    await fetch(`/api/files?transferId=${transferToDelete}&delete=${selectedIds.map(encodeURIComponent).join(',')}`, {
                        method: 'POST'
                    });
                } catch (error) {
                    console.warn('Partial delete endpoint not implemented, local files removed only');
                }
            }
        }

        function openUploadsDeleteOverlay() {
            if (!uploadedFiles.length) {
                showEmptyJournalState();
                updateProvsvarStatus();
                return;
            }
            
            const dateLabel = new Date().toLocaleDateString('sv-SE');
            const filesList = uploadedFiles.map(file => `
                <label class="delete-file-item">
                    <span>
                        <span class="file-name">${file.name}</span>
                        <span class="file-meta">${new Date(file.uploadedAt).toLocaleDateString('sv-SE')} • ${Math.round(file.size/1024)} KB</span>
                    </span>
                    <input type="checkbox" class="delete-file-checkbox" value="${file.name}" checked>
                </label>
            `).join('');
            
            const title = uploadedFiles.length === 1 ? uploadedFiles[0].name : `${uploadedFiles.length} filer valda`;
            
            const overlayHTML = `
                <div class="delete-overlay" id="uploadsDeleteOverlay">
                    <div class="delete-modal">
                        <div class="delete-modal-header">
                            <h2 class="delete-modal-title">Radera filer</h2>
                            <p class="delete-modal-subtitle">Är du säker på att du vill radera alla mottagna filer?</p>
                        </div>
                        <div class="delete-modal-content">
                            <div class="delete-info-card">
                                <div class="delete-info-header">
                                    <div>
                                        <h4 class="delete-info-title">${title}</h4>
                                        <p class="delete-info-text">Datum: ${dateLabel}</p>
                                    </div>
                                    <button class="select-all-btn" onclick="toggleSelectAllFiles()">Markera alla</button>
                                </div>
                                <div class="delete-files-list">
                                    ${filesList}
                                </div>
                                <p class="delete-info-text" style="margin-top: 12px; font-style: italic; color: #999;">Denna åtgärd kan inte ångras.</p>
                            </div>
                        </div>
                        <div class="delete-modal-actions">
                            <button class="delete-btn-cancel" onclick="closeUploadsDeleteOverlay()">Avbryt</button>
                            <button class="delete-btn-confirm" onclick="confirmUploadsDelete()">
                                <svg class="delete-btn-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="3,6 5,6 21,6"></polyline>
                                    <path d="M19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path>
                                    <line x1="10" y1="11" x2="10" y2="17"></line>
                                    <line x1="14" y1="11" x2="14" y2="17"></line>
                                </svg>
                                Radera
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', overlayHTML);
            const overlay = document.getElementById('uploadsDeleteOverlay');
            requestAnimationFrame(() => overlay.classList.add('active'));
            attachDeleteFileCheckboxHandlers();
            updateDeleteSelectAllButton();
            
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeUploadsDeleteOverlay();
                }
            });
            
            document.addEventListener('keydown', handleUploadsDeleteEscapeKey);
        }

        function attachDeleteFileCheckboxHandlers() {
            const checkboxes = document.querySelectorAll('.delete-file-checkbox');
            checkboxes.forEach(cb => cb.addEventListener('change', updateDeleteSelectAllButton));
        }

        function updateDeleteSelectAllButton() {
            const checkboxes = document.querySelectorAll('.delete-file-checkbox');
            const selectAllBtn = document.querySelector('.select-all-btn');
            if (!selectAllBtn) return;
            const allChecked = checkboxes.length > 0 && Array.from(checkboxes).every(cb => cb.checked);
            selectAllBtn.textContent = allChecked ? 'Avmarkera alla' : 'Markera alla';
        }

        function toggleSelectAllFiles() {
            const checkboxes = document.querySelectorAll('.delete-file-checkbox');
            const allChecked = checkboxes.length > 0 && Array.from(checkboxes).every(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !allChecked);
            updateDeleteSelectAllButton();
        }

        function getSelectedFilesForDeletion() {
            const checkboxes = document.querySelectorAll('.delete-file-checkbox');
            if (!checkboxes.length) {
                return null;
            }
            const selected = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.value);
            return selected.length === checkboxes.length ? null : selected;
        }

        function closeUploadsDeleteOverlay() {
            const overlay = document.getElementById('uploadsDeleteOverlay');
            if (overlay) {
                overlay.classList.remove('active');
                setTimeout(() => overlay.remove(), 300);
            }
            document.removeEventListener('keydown', handleUploadsDeleteEscapeKey);
        }

        function handleUploadsDeleteEscapeKey(e) {
            if (e.key === 'Escape') {
                closeUploadsDeleteOverlay();
            }
        }

        async function confirmUploadsDelete() {
            const confirmBtn = document.querySelector('#uploadsDeleteOverlay .delete-btn-confirm');
            if (!confirmBtn) return;
            const originalText = confirmBtn.innerHTML;
            confirmBtn.innerHTML = 'Raderar...';
            confirmBtn.disabled = true;
            
            const selected = getSelectedFilesForDeletion();
            await performDeleteUploads(selected);
            
            confirmBtn.innerHTML = originalText;
            confirmBtn.disabled = false;
            closeUploadsDeleteOverlay();
        }


        function showLogoutOverlay() {
            const overlay = document.getElementById('logout-overlay');
            overlay.style.display = 'flex';
            setTimeout(() => {
                overlay.classList.add('active');
            }, 10);
        }

        function hideLogoutOverlay() {
            const overlay = document.getElementById('logout-overlay');
            overlay.classList.remove('active');
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        }


        async function confirmLogout() {
            console.log('LOGOUT: Resetting entire platform - deleting ALL files');
            
            // STEP 1: Clear UI immediately - remove ALL files (PDF and Excel)
            uploadedFiles = [];
            currentTransferId = null;
            
            const categoriesContainer = document.getElementById('file-categories');
            if (categoriesContainer) {
                categoriesContainer.innerHTML = '<p class="empty-category">Inga filer att visa</p>';
            }
            
            const journalContent = document.querySelector('.journal-content');
            if (journalContent) {
                journalContent.innerHTML = '';
            }
            
            updateFileDisplay();
            clearAllFiles();
            
            // STEP 2: Delete ALL files from server FIRST
            try {
                const response = await fetch('/api/logout', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                if (response.ok) {
                    console.log('✅ Server deleted ALL files and transfers');
                } else {
                    console.error('Failed to delete server files');
                }
            } catch (error) {
                console.error('Error deleting server files:', error);
            }
            
            // STEP 3: Wait for server to complete deletion
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // STEP 4: Clear ALL localStorage - EVERYTHING related to files
            const allKeys = Object.keys(localStorage);
            allKeys.forEach(key => {
                if (key.startsWith('mmd_files_') || 
                    key.startsWith('transfer_') || 
                    key.startsWith('patient_transfer_') ||
                    key.startsWith('excel_cache_') ||
                    key === 'currentTransferId' ||
                    key === 'currentPatientName' ||
                    key === 'uploadedFiles' ||
                    key === 'sessionStartTime' ||
                    key === 'uploadNotificationShownForSession') {
                    localStorage.removeItem(key);
                    console.log('Deleted:', key);
                }
            });
            
            // Clear auth (but keep for login)
            localStorage.removeItem('hasSeenLogin');
            localStorage.removeItem('mmdcare_auth');
            
            console.log('✅ Platform completely reset - all files deleted');
            
            // Close event streams
            if (eventSource) {
                eventSource.close();
            }
            
            hideLogoutOverlay();
            
            // Redirect to login
            window.location.href = 'login.html';
        }

        function initializeJournalCard() {
            // Find the Journalanteckningar card
            const journalCards = document.querySelectorAll('.organ-item');
            journalCards.forEach(card => {
                const title = card.querySelector('.organ-name');
                if (title && title.textContent === 'Journalanteckningar') {
                    // Make the card clickable
                    const link = card.closest('.organ-item-link');
                    if (link) {
                        link.href = 'javascript:void(0)';
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            toggleJournalCard(card);
                        });
                    }
                }
            });
        }

        function toggleJournalCard(card) {
            // Check if journal content container exists
            let journalContainer = card.closest('.organ-item-link')?.querySelector('.journal-expandable-content');
            
            if (!journalContainer) {
                // Create the container directly inside the card's parent link
                const link = card.closest('.organ-item-link');
                if (!link) return;
                
                journalContainer = document.createElement('div');
                journalContainer.className = 'journal-expandable-content';
                journalContainer.style.cssText = `
                    display: none;
                    margin-top: 16px;
                    padding: 20px;
                    background: #f8fafc;
                    border-radius: 12px;
                    border: 1px solid #e5e7eb;
                    width: 100%;
                `;
                
                // Insert after the card
                link.appendChild(journalContainer);
            }
            
            const isExpanded = journalContainer.style.display !== 'none';
            const chevron = card.querySelector('.chevron');
            
            if (isExpanded) {
                journalContainer.style.display = 'none';
                if (chevron) chevron.style.transform = 'rotate(0deg)';
                card.classList.remove('expanded');
            } else {
                journalContainer.style.display = 'block';
                if (chevron) chevron.style.transform = 'rotate(90deg)';
                card.classList.add('expanded');
                
                // Check if we need to reload (new PDFs added) or if already loaded
                const pdfFiles = uploadedFiles.filter(file =>
                    file.mimetype === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')
                );
                const currentPdfCount = journalContainer.querySelectorAll('.pdf-journal-entry').length;
                
                // Only reload if container is empty or PDF count changed
                if (journalContainer.children.length === 0 || currentPdfCount !== pdfFiles.length) {
                    journalContainer.dataset.loaded = 'false';
                    journalContainer.innerHTML = '';
                    loadJournalEntriesIntoContainer(journalContainer);
                }
            }
        }

        async function loadJournalEntriesIntoContainer(container) {
            // Check if already loaded to prevent duplicates
            if (container.dataset.loaded === 'true') {
                return;
            }
            
            container.innerHTML = '<p style="color: #666;">Laddar journalanteckningar...</p>';
            
            const pdfFiles = uploadedFiles.filter(file =>
                file.mimetype === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')
            );
            
            if (pdfFiles.length === 0) {
                container.innerHTML = '<p style="color: #666;">Inga journalanteckningar tillgängliga.</p>';
                container.dataset.loaded = 'true';
                return;
            }
            
            container.innerHTML = '';
            
            // Load each PDF and create entry
            const loadPromises = pdfFiles.map(async (pdfFile) => {
                try {
                    const response = await fetch(`/api/pdf-content?transferId=${currentTransferId}&filename=${encodeURIComponent(pdfFile.name)}`);
                    if (response.ok) {
                        const parsedData = await response.json();
                        return createPDFJournalCard(pdfFile, parsedData);
                    } else {
                        return createBasicPDFCard(pdfFile);
                    }
                } catch (error) {
                    console.error(`Failed to load PDF content for ${pdfFile.name}:`, error);
                    return createBasicPDFCard(pdfFile);
                }
            });
            
            const cards = await Promise.all(loadPromises);
            cards.forEach(card => container.appendChild(card));
            
            // Mark as loaded
            container.dataset.loaded = 'true';
        }

        function initializeMetricsTabs() {
            const tabGroups = document.querySelectorAll('.metrics-tabs');
            if (!tabGroups.length) return;

            tabGroups.forEach(group => {
                const tabs = group.querySelectorAll('.metrics-tab');
                const panels = group.querySelectorAll('.tab-panel');
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const target = tab.getAttribute('data-tab');
                        tabs.forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        panels.forEach(panel => {
                            const match = panel.getAttribute('data-tab-panel') === target;
                            panel.classList.toggle('active', match);
                        });
                    });
                });
            });
        }

        function getImportOverlayElements() {
            return {
                overlay: document.getElementById('importOverlay'),
                progressBar: document.getElementById('importProgressBar'),
                progressText: document.getElementById('importProgressText'),
                titleEl: document.getElementById('importOverlayTitle'),
                copyEl: document.getElementById('importOverlayCopy'),
                trackEl: document.getElementById('importProgressTrack'),
                iconEl: document.getElementById('importOverlayIcon')
            };
        }

        function showImportOverlay(totalSteps = 0, options = {}) {
            const mode = options.mode || 'import';
            const { overlay, progressBar, progressText, titleEl, copyEl, trackEl, iconEl } = getImportOverlayElements();
            if (!overlay) return;

            if (mode === 'waiting' && !options.force) {
                // Always show overlay if there are no files (regardless of flag)
                if (uploadedFiles.length === 0) {
                    // Show overlay - don't mark as seen yet, wait until files arrive
                } else if (hasSeenWaitingOverlay()) {
                    // Skip if we've seen it AND there are already files
                    return;
                } else {
                    // Files exist but we haven't seen overlay - mark it now
                    markWaitingOverlaySeen();
                }
            }

            if (importOverlayState.timerId) {
                clearInterval(importOverlayState.timerId);
                importOverlayState.timerId = null;
            }

            importOverlayState.visible = true;
            importOverlayState.totalSteps = totalSteps;
            importOverlayState.mode = mode;

            overlay.classList.add('visible');
            overlay.setAttribute('aria-hidden', 'false');
            document.body.classList.add('import-locked');

            if (mode === 'waiting') {
                if (titleEl) titleEl.textContent = 'Väntar på uppladdning av data från patient';
                if (copyEl) copyEl.textContent = 'Be patienten att slutföra uppladdningen. Plattformen låses tills data är mottagen.';
                if (progressText) progressText.textContent = 'Ingen data mottagen ännu';
                if (trackEl) trackEl.style.display = 'none';
                if (progressBar) progressBar.style.width = '0%';
                if (iconEl) iconEl.textContent = '⏳';
                return;
            }

            if (titleEl) titleEl.textContent = 'Importerar patientdata';
            if (copyEl) copyEl.textContent = 'Detta tar vanligtvis mindre än 30 sekunder.';
            if (trackEl) trackEl.style.display = 'block';
            if (progressBar) {
                progressBar.style.width = '6%';
            }
            if (progressText) {
                progressText.textContent = 'Förbereder import...';
            }
            if (iconEl) iconEl.textContent = '⬆︎';

            importOverlayState.timerId = setInterval(() => {
                if (!importOverlayState.visible || !progressBar || importOverlayState.mode !== 'import') return;
                const currentWidth = parseFloat(progressBar.style.width) || 0;
                if (currentWidth < 90) {
                    const increment = Math.random() * 5 + 1;
                    progressBar.style.width = `${Math.min(currentWidth + increment, 90)}%`;
                }
            }, 1000);
        }

        function updateImportOverlayProgress(completed, total) {
            if (!importOverlayState.visible || importOverlayState.mode !== 'import') return;
            const { progressBar, progressText } = getImportOverlayElements();
            if (progressBar) {
                const pct = Math.max((completed / total) * 100, 10);
                progressBar.style.width = `${Math.min(pct, 96)}%`;
            }
            if (progressText) {
                progressText.textContent = `Importerar patientdata (${completed}/${total})`;
            }
        }

        function showPDFPreview(transferId, filename, displayName) {
            // Create overlay for PDF preview
            const overlay = document.createElement('div');
            overlay.className = 'pdf-preview-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                z-index: 10001;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: white;
                border-radius: 12px;
                width: 100%;
                max-width: 90vw;
                max-height: 90vh;
                display: flex;
                flex-direction: column;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            `;
            
            const header = document.createElement('div');
            header.style.cssText = `
                padding: 16px 20px;
                border-bottom: 1px solid #e5e7eb;
                display: flex;
                justify-content: space-between;
                align-items: center;
            `;
            header.innerHTML = `
                <h3 style="margin: 0; font-size: 18px; font-weight: 600;">${displayName}</h3>
                <button onclick="this.closest('.pdf-preview-overlay').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">&times;</button>
            `;
            
            const iframe = document.createElement('iframe');
            // Use the PDF file endpoint from transfer server
            iframe.src = `/pdf-file/${transferId}/${filename}`;
            iframe.style.cssText = `
                width: 100%;
                height: calc(90vh - 60px);
                border: none;
                border-radius: 0 0 12px 12px;
            `;
            
            modal.appendChild(header);
            modal.appendChild(iframe);
            overlay.appendChild(modal);
            
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            });
            
            document.body.appendChild(overlay);
        }

        function finishImportOverlay(options = {}) {
            if (!importOverlayState.visible) return;
            const immediate = options.immediate || false;
            const { overlay, progressBar, progressText } = getImportOverlayElements();
            if (importOverlayState.timerId) {
                clearInterval(importOverlayState.timerId);
                importOverlayState.timerId = null;
            }

            const hideOverlay = () => {
                if (overlay) {
                    overlay.classList.remove('visible');
                    overlay.setAttribute('aria-hidden', 'true');
                }
                document.body.classList.remove('import-locked');
                importOverlayState.visible = false;
                importOverlayState.mode = null;
            };

            if (importOverlayState.mode === 'waiting' || immediate) {
                hideOverlay();
                return;
            }

            if (progressBar) {
                progressBar.style.width = '100%';
            }
            if (progressText) {
                progressText.textContent = 'Import klar';
            }
            setTimeout(hideOverlay, 600);
        }

    </script>
</body>
</html>
